// MyTlsSSP.cpp
// g++ -shared -o MyTlsSSP.dll exploit.cpp -static-libgcc -static-libstdc++ -Wl,--subsystem,windows
#include <windows.h>
#include <sspi.h>
#include <ntsecapi.h>
#include <ntsecpkg.h>
#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib, "Secur32.lib")

static HMODULE hSchannel = NULL;
static decltype(&InitializeSecurityContextW) RealInitSecCtx = NULL;

// Event logging helper
void LogEvent(const wchar_t* msg) {
    HANDLE hEvent = RegisterEventSource(NULL, L"MyTlsSSP"); 
    if (hEvent) {
        ReportEvent(hEvent, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, &msg, NULL);
        DeregisterEventSource(hEvent);
    }
}

// SpGetInfo: Provide package name matching registry entry (no “.dll”).
extern "C" __declspec(dllexport)
NTSTATUS NTAPI SpGetInfo(PSecPkgInfoW pInfo) {
    pInfo->Name = (SEC_WCHAR*)L"MyTlsSSP";          // SSP package name
    pInfo->Comment = (SEC_WCHAR*)L"My TLS Forwarding SSP";
    pInfo->fCapabilities = SECPKG_FLAG_CONNECTION;  // TLS = connection-oriented
    pInfo->wVersion = 1;
    pInfo->cbMaxToken = 0;  // use default max
    return SEC_E_OK;
}

// SpInitialize: Called by LSA once. Load Schannel DLL for forwarding.
extern "C" __declspec(dllexport)
NTSTATUS NTAPI SpInitialize(ULONG_PTR /*PackageId*/, 
                            PSECPKG_PARAMETERS /*Params*/, 
                            PLSA_SECPKG_FUNCTION_TABLE FuncTable) 
{
    // Load Schannel for SSPI calls
    if (!hSchannel) {
        hSchannel = LoadLibraryW(L"schannel.dll");
        if (hSchannel) {
            RealInitSecCtx = (decltype(RealInitSecCtx))
                GetProcAddress(hSchannel, "InitializeSecurityContextW");
            // Load other needed Schannel functions similarly...
        }
    }
    return STATUS_SUCCESS;
}

// Example of hooking InitializeSecurityContext to log usage
NTSTATUS NTAPI MyInitializeSecurityContext(
    PCredHandle phCredential, PCtxtHandle phContext, SEC_WCHAR* pszTargetName,
    unsigned long fContextReq, unsigned long Reserved1,
    unsigned long TargetDataRep, PSecBufferDesc pInput, unsigned long Reserved2,
    PCtxtHandle phNewContext, PSecBufferDesc pOutput, unsigned long* pfContextAttr,
    PTimeStamp ptsExpiry)
{
    // Log that a TLS handshake is happening
    LogEvent(L"MyTlsSSP: InitializeSecurityContext called");
    // Forward call to real Schannel InitializeSecurityContextW
    return RealInitSecCtx(phCredential, phContext, pszTargetName,
                          fContextReq, Reserved1, TargetDataRep,
                          pInput, Reserved2, phNewContext,
                          pOutput, pfContextAttr, ptsExpiry);
}

// SpLsaModeInitialize: LSA calls this to register our callbacks
extern "C" __declspec(dllexport)
NTSTATUS NTAPI SpLsaModeInitialize(
    ULONG /*LsaVersion*/, 
    PULONG PackageVersion, 
    PSECPKG_FUNCTION_TABLE* ppTables, 
    PULONG pcTables)
{
    *PackageVersion = SECPKG_INTERFACE_VERSION;
    *pcTables = 1;
    static SECPKG_FUNCTION_TABLE Table = {0};

    // Populate function table
    Table.Initialize = SpInitialize;
    Table.Shutdown   = [](VOID){ return STATUS_SUCCESS; }; 
    Table.GetInfo    = SpGetInfo;
    // Only overriding InitializeSecurityContext as example:
    // In actual code, assign other necessary callbacks similarly.
    Table.AcceptCredentials = NULL; 
    // ... (other callbacks set to NULL or real Schannel ones) ...
    // Replace InitializeSecurityContext with our wrapper:
    Table.InitializeSecurityContext = MyInitializeSecurityContext;

    *ppTables = &Table;

    // Log that our SSP was loaded
    LogEvent(L"MyTlsSSP loaded into LSASS");
    return SEC_E_OK;
}
